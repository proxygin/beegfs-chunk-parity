#!/usr/bin/python2
# -*- coding: utf-8 -*-

import os
import sys
import time
import struct
import optparse

chunks_modified = {}

FILEMOD_PATH = "/dev/shm/chunkmod_intercept"

'''
1. Find alle filer i /dev/shm/chunkmod_intercept
2. Exclude alle filer som ikke ligger inde for intervallet
3. Parse hver enkel fil og append linjer som indeholder filer der er blevet
   modeficeret
'''

def get_files(path,lowerbound,upperbound):
    f = []
    for (dirpath, dirnames, filenames) in os.walk(path):
        f.extend(filenames)
        break

    retlist = []
    for file in f:
        stat = os.stat(os.path.join(path,file))

        # if st_mtime < lowerbound => All entries to old
        # if st_ctime > upperbound => All entries to new
        if stat.st_ctime > upperbound or stat.st_mtime < lowerbound:
            continue
        
        retlist.append(os.path.join(path,file))

    return retlist

def write_to_stdout():
    ''' Convert entry into easy C parseble types.
        * 8-byte unsigned int for timestamp followed by
        * 8-byte insigned int for the size of the file in bytes(stat.st_size)
        * 8-byte unsigned int denoting the lenght of the coming string
        * The string itself

        Repeat this pattern without any seperators.

        Write output to stdout.
    '''
    for path,timestamp in chunks_modified.items():
        time_b = struct.pack('<Q',int(timestamp))
        #size_b = struct.pack('<Q',int(size))
        len_b  = struct.pack('<Q',len(path))

        #time_b = struct.pack('<l',int(1684960616))
        #len_b = struct.pack('<L',255)

        sys.stdout.write(time_b+len_b+path)


def insert(entries):
    for timestamp,path in entries:
        if path in chunks_modified.keys() and timestamp < chunks_modified[path]:
            continue
        else:
            chunks_modified[path] = timestamp

def parse(file,lowerbound,upperbound):
    ''' Takes a string as input and parses it into tuples of (timestamp, path).
    Note: We can use the fact that each thread writes to its own file. This will
    ensure that input is sorted by timestamp '''

    valid_entries = []
    for entry in file:
        timestamp,path = entry.strip().split(' ')
        timestamp = int(timestamp)
        if timestamp < upperbound and timestamp > lowerbound:
            valid_entries.append([timestamp,path])

    return valid_entries


def construct_chunkmod_data(path,lowerbound,upperbound):
    files = get_files(path,lowerbound,upperbound)
    for filename in files: 
        with open(filename,'r') as file:
            entries = parse(file,lowerbound,upperbound)
            insert(entries)

    write_to_stdout()
    
def cleanup_until(until):
    ''' When a log entry is being written it will update the st_mtime of a log
    file. To gather all relevant log files contaning log entries up until a
    given point in time, can therefore be done only by looking at the st_mtime
    of the logfiles themself. ''' 

    #Get all files whichs stat.st_mtime is less than until
    filelist = get_files(FILEMOD_PATH,0,until)
    for file in filelist:
        print file
        #os.remove(file)


def main():
    parser = optparse.OptionParser(usage="""Usage: %prog [--from <timestamp> --to <timestamp>|--cleanup-until <timestamp>]"

%prog costructs a list of files that have been modified within the given time 
interval. It does this by looking at the logs files generated by a LD_PRELOAD'ed
chunkmod module to beegfs-storage.

The output format is constructed to be easy parserable in C.
Format: <time_t><len><str>
    time_t: 8 byte unsigned int contaning timestamp of chunkmod.
    len: 8 byte unsigned int denoting the lenght of the coming string
    str: char array of the above lenght contating the path of the file


Filemod log that has been processed can be removed by via --cleanup-until.""",
                                   version="%prog 1.0")
    parser.add_option("-f", "--from", dest="from_t", type="int",
                      help="Include changes made 'from_t'", metavar="TIMESTAMP")
    parser.add_option("-t", "--to"  , dest="to_t"  , type="int",
                      help="Include changes made until 'to_t'", metavar="TIMESTAMP")
    parser.add_option("-c", "--cleanup-until", dest="clean_t", type="int",
                      help="Delete chunkmod logs until given timestamp.", metavar="TIMESTAMP")

    (options, args) = parser.parse_args()

    if options.from_t is not None and options.to_t is not None:
        construct_chunkmod_data(FILEMOD_PATH,options.from_t,options.to_t)

    elif options.clean_t is not None:
        cleanup_until(options.clean_t)
    else:
        print parser.usage


if __name__ == "__main__":
    main()
